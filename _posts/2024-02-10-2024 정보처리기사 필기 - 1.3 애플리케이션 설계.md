---
layout: post
title: 2024 정보처리기사 필기 - 1.3 애플리케이션 설계
subtitle: 2024 정보처리기사 필기 - 1 소프트웨어 설계
tags: [정보처리기사필기]
---
> 2024 정보처리기사 필기 정리

# PART 1. 소프트웨어 설계
## Chapter 3. 애플리케이션 설계
### Section 1. 공통 모듈 설계

- 협약에 의한 설계 : 동작에 필요한 여러 가정을 정의하고 공유
  - 선행 조건 : 동작하기 전 만족되어야 하는 조건
  - 결과 조건 : 동작 후 기대되는 결과나 상태
  - 불변 조건 : 동작하는 동안 항상 참이어야 하는 조건
<br/><br/>

- 설계의 종류
  - 상위 설계
  - 하위 설계 : 모듈 설계, 자료구조 설계, 알고리즘 설계
<br/><br/>

- 설계의 원리
  - 분할과 정복
  - 추상화
    - 추상화 기법 : 과정 추상화, 데이터 추상화, 제어 추상화
  - 단계적 분해
  - 모듈화
  - 정보은닉
<br/><br/>

- 소프트웨어 아키텍처 품질속성
  - 정확성
  - 신뢰성
  - 효율성
  - 무결성
  - 사용 용이성
  - 유지 보수성
  - 시험 용이성
  - 유연성
  - 이식성
  - 재사용성
  - 상호 운용성
<br/><br/>

- 소프트웨어 아키텍처의 특징
  - 간략성
  - 추상화
  - 가시성
  - 관점 모형
  - 의사소통수단
<br/><br/>

- 소프트웨어 아키텍처 4+1 뷰
  - 논리적 관점
  - 구현 관점
  - 프로세스 관점
  - 배치 관점
  - +1 (사용자) : 유스케이스 관점
<br/><br/>

- 소프트웨어 아키텍처 패턴
  - 계층화 패턴
  - 클라이언트-서버 패턴 : 다수의 클라이언트와 하나의 서버
  - 마스터-슬레이브 패턴
  - 파이프-필터 패턴 : 데이터는 파이프를 통해 한 쪽 방향으로 흐름
  - 브로커 패턴
  - 피어 투 피어 패턴
  - 이벤트-버스 패턴
  - 모델-뷰-컨트롤러 패턴(MVC Pattern)
  - 블랙보드 패턴
  - 인터프리터 패턴
<br/><br/>

- 공통 모듈 재사용 범위에 따른 분류
  - 함수와 객체
  - 컴포넌트
  - 애플리케이션
<br/><br/>

- 공통 모듈 작성 원칙
  - 정확성
  - 명확성
  - 완전성
  - 일관성
  - 추적성
<br/><br/>

- 독립성이 높은 잘 설계된 모듈
  - 응집도(모듈 내부) 높을수록
  - 결합도(모듈과 모듈 간) 낮을수록
<br/><br/>

- ⭐**응집도 유형 (저 -> 고)**
  - 우연적 응집도 : 연관 없음
  - 논리적 응집도 : 유사한 성격
  - 시간적 응집도 : 특정 시간에 처리
  - 절차적 응집도 : 순차적으로 수행
  - 통신적 응집도 : 동일한 입력과 출력
  - 순차적 응집도 : 한 활동으로부터 나온 출력값을 다른 활동이 사용
  - 기능적 응집도 : 모든 기능이 단일 목적
<br/><br/>

- ⭐**결합도 유형 (저 -> 고)**
  - 자료 결합도 : 값 전달
  - 스탬프 결합도 : 배열, 오브젝트, 스트럭처 등 전달
  - 제어 결합도 : 제어 요소 전달
  - 외부 결합도 : 데이터를 외부의 모듈에서 참조
  - 공통 결합도 : 전역 변수 참조
  - 내용 결합도
<br/><br/>

- 팬인(Fan-In), 팬아웃(Fan-Out)
  - 팬인 : 상위 모듈 수, 높게 설계
  - 팬아웃 : 하위 모듈 수, 낮게 설계
<br/><br/>

- 코드의 유형
  - 순차 코드
  - 블록 코드
  - 10진 코드
  - 그룹 분류 코드
  - 연상 코드 : 명칭과 관계
  - 표의 숫자 코드 : 중량, 면적, 용량
  - 합성 코드
<br/><br/>

- 코드의 오류 발생 형태
  - 생략 오류(Omission)
  - 필사 오류(Transcription)
  - 전위 오류(Transposition) : 좌우 자리를 바꾸어 기록
  - 이중 오류(Double Transposition)
  - 추가 오류(Addition)
  - 임의 오류(Random)
<br/><br/>

### Section 2. 객체지향 설계

- 객체지향 구성요소
  - 클래스 : 유사한 종류의 존재를 속성과 연산을 정의해서 만든 틀, 데이터를 추상화하는 단위
  - 객체 : 클래스의 인스턴스
  - 속성 : 객체들이 가지고 있는 고유한 데이터
  - 메서드 : 명령문의 집합
  - 메세지 : 객체에게 행위를 하도록 지시
<br/><br/>

- ⭐**객체지향언어의 특징**
  - 캡슐화 : 속성과 메서드를 묶어 정보 은닉
  - 정보은닉 : 객체의 내부 데이터에 직접 접근할 수 없도록 제한
  - 상속 : 상위 클래스를 물려받는 것
  - 다형성
    - 오버로딩 : 동일한 메서드명을 인자값의 유형이나 개수를 다르게
    - 오버라이딩 : 상속받은 메서드 재정의
  - 추상화 : 공통적인 메서드 정의
<br/><br/>

- ⭐**객체지향 설계원칙**
  - 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 한다
  - 개방 폐쇄 원칙 : 확장에 대해 열려 있어야 하지만, 수정에 대해서는 닫혀 있어야 한다
  - 리스코프 치환 원칙 : 자식 클래스는 부모 클래스를 대체할 수 있어야 한다
  - 인터페이스 분리 원칙 : 사용하지 않는 인터페이스는 구현하지 말아야 한다
  - 의존성 역전 원칙 : 변화가 거의 없는 것에 의존해야 한다
<br/><br/>

- 디자인 패턴 구성요소
  - 패턴의 이름과 유형
  - 문제 및 배경
  - 솔루션
  - 사례
  - 결과
  - 샘플 코드
<br/><br/>

- GoF의 디자인 패턴 : 생성, 구조, 행위 3가지로 분류
<br/><br/>

- 생성 패턴 : 객체 생성에 관련된 패턴
  - 추상 팩토리(Abstract Factory)
  - 빌더(Builder)
  - 팩토리 메서드(Factory Method)
  - 프로토타입(Prototype)
  - 싱글톤(Singleton)
<br/><br/>

- 구조 패턴 : 더 큰 구조를 만드는 패턴
  - 어댑터(Adapter) : 클래스의 인터페이스를 다른 인터페이스로 변환
  - 브리지(Bridge) : 구현부에서 추상층을 분리
  - 컴포지트(Composite) : 객체들의 관계를 트리구조로 구성
  - 데코레이터(Decorator) : 어떤 객체에 다른 객체를 덧붙이는 방식
  - 퍼사드(Facade) : 하나의 통합된 인터페이스를 제공
  - 플라이웨이트(Flyweight) : 크기가 작은 여러개의 객체 공유할 수 있도록 하여 메모리를 절약
  - 프록시(Proxy) : 대리나 대체글을 제공
<br/><br/>

- 행위 패턴 : 상호작용하는 방법을 정의하는 패턴
  - 책임 연쇄(Chain of Responsibility)
  - 커맨드(Command)
  - 인터프리터(Interpreter) : 언어 해석
  - 반복자(Iterator) : 반복 작업
  - 중재자(Mediator) : 중재자 객체를 통해 통신
  - 메멘토(Memento) : 상태 정보를 저당
  - 옵서버(Observer) : 상태 변화를 관찰
  - 상태(State)
  - 전략(Strategy) : 알고리즘
  - 템플릿 메서드(Template Method)
  - 방문자(Visitor) : 객체 구조를 변경하지 않아도 된다
