---
layout: post
title: 2024 정보처리기사 필기 - 2.4 애플리케이션 테스트 관리
subtitle: 2024 정보처리기사 필기 - 2 소프트웨어 개발
tags: [정보처리기사필기]
---
> 2024 정보처리기사 필기 정리

# PART 2. 소프트웨어 개발
## Chapter 4. 애플리케이션 테스트 관리
### Section 1. 애플리케이션 테스트케이스 설계

- ⭐**소프트웨어 테스트의 기본 원칙**
  - 테스팅 : 결함을 찾아내는 활동
  - 완벽한 테스팅은 불가능
  - 개발 초기에 시작
  - 결함 집중
    - 결함은 대부분 소수의 특정한 모듈에 집중
    - 파레토 법칙 : 전체 결과의 80%가 전체 원인의 20%에서 일어나는 현상
  - 살충제 패러독스 : 반복적인 테스트로는 새로운 결함을 찾기 어려움
  - 테스팅 방법은 특정 상황에 의존적
  - 오류-부재의 궤변 : 오류가 없다고 해도 사용자의 요구사항을 충족하지 않으면 품질이 좋다고 할 수 없음
<br/><br/>

- 테스트 산출물
  - 테스트 계획서
  - 테스트 케이스 : 입력, 실행 조건, 기대 결과를 포함한 명세서
  - 테스트 시나리오 : 테스트 케이스의 동작 순서를 기술한 문서
  - 테스트 결과서
<br/><br/>

- ⭐**테스트 오라클**
  - 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참 값을 입력하여 비교하는 기법 및 활동
  - 유형
    - 참 오라클 : 모든 입력 값에 대해 정확한 결과를 생성
    - 샘플링 오라클 : 제한된 입력 값에 대한 결과를 제공, 일반적
    - 휴리스틱 오라클 : 근사적인 결과를 제공
    - 일관성 검사 오라클 : 변경 전후 일관성을 검증
<br/><br/>

- ⭐**테스트 레벨**
  1. 단위 테스트 : 모듈 검증
    - 정적 테스트 : 소프트웨어 실행 없이 / 코드검사, 인스펙션, 워크스루
    - 동적 테스트 : 소프트웨어 실행
  2. 통합 테스트 : 인터페이스 검증
    - 점증적 방식
      - 상향식 통합 테스트
        - Botton Up
        - 클러스터(Cluster)로 결합
        - 아직 개발되지 않은 상위 모듈은 더미 모듈인 드라이버(Driver)를 개발하여 진행
      - 하향식 통합 테스트
        - Top Down
        - 깊이-우선 또는 너비-우선 방식으로 통합
        - 아직 개발되지 않은 하위 모듈은 더미 모듈인 스텁(Stub)을 개발하여 진행
    - 비점증적 방식
      - 빅뱅 테스트
        - 한꺼번에 테스트
        - 소규모 시스템에 편리
        - 단점 : 장애가 일어난 위치를 파악하기 어려움
      - 백본 테스트
        - 상향식과 하향식의 장점을 이용, 샌드위치 테스트
        - 비용이 많이 들어감
  3. 시스템 테스트 : 요구 분석 검증
    - 기능 테스트
      - 기능 확인
    - 비기능 테스트
      - 성능, 신뢰성, 안정성, 유효성, 적합성 확인
  4. 인수 테스트
    - 알파 테스트
      - 개발자의 통제 하에 사용자가 테스트
    - 베타 테스트
      - 사용자가 테스트
<br/><br/>

- 테스트 기법
  - 화이트박스 테스트
    - 개발자 관점
    - 테스트 기법
      - 문장 검증
      - 선택 검증
      - 경로 검증
      - 조건 검증
    - 기초 경로 검사 : McCabe, V = E-N+2
  - 블랙박스 테스트
    - 사용자 관점
    - ⭐**테스트 기법**
      - 동등 분할 기법
      - 경계값 분석
      - 원인-효과 그래프 검사
      - 오류 예측 검사
      - 비교 검사
      - 상태 점이 검사
<br/><br/>

- 테스트 커버리지
  - 테스트를 얼마나 수행했는지 측정하는 기준
  - 유형
    - 기능 기반 커버리지 : 전체 기능을 모수로 설정
    - 라인 커버리지 : Line 수를 모수로 설정
    - 코드 커버리지 : 구문, 조건, 결정
      - 구문 커버리지 : 모든 구문
      - 조건 커버리지 : 개별 조건식 각각 T/F 만족, 전체 결정포인트 T/F 보장받지 못함
      - 결정 커버리지 : 결정포인트 각각 T/F 만족, 개별 조건식 오류 찾지 못할 수 있음
      - 조건/결정 커버리지 : 결정포인트 T/F, 개별조건식 T/F
      - 변경 조건/결정 커버리지 : 적어도 한 번 T/F
      - 다중 조건 커버리지 : 가능한 조합 100% 보장
<br/><br/>

### Section 2. 애플리케이션 통합 테스트

- 결함 관리 측정 지표
  - 결함 분포 : 결함의 수를 측정
  - 결함 추세 : 시간 흐름에 따른 결함의 수 측정
  - 결함 에이징 : 결함 상태의 지속 시간 측정
<br/><br/>

- 테스트 자동화 도구 : 스크립트 활용하여 반복적인 테스트 작업을 자동화
<br/><br/>

- 테스트 자동화 도구 유형
  - 정적 분석 도구
  - 테스트 실행 도구
  - 성능 테스트 도구
  - 테스트 통제 도구
  - 테스트 장치
    - 테스트 장치 구성요소
      - 테스트 드라이버 : 상향식 테스트
      - 테스트 스텁 : 하향식 테스트
      - 테스트 슈트 : 테스트 케이스의 집합
      - 테스트 케이스 : 입력 값, 실행 조건, 기대 결과 등의 집합
      - 테스트 스크립트 : 명세
      - 목 오브젝트 : 행위를 조건부로 사전에 입력해두면, 그 상황에 예정된 행위를 수행
<br/><br/>

### Section 3. 애플리케이션 성능 개선

- 알고리즘 설계 기법
  - 분할과 정복 : 더 작은 문제로 나누어 해결
  - 동적 계획법 : 작은 문제들에서 구한 해를 활용
  - 탐욕법 : 그때 그때 가장 좋은 선택
  - 백트래킹 : 해가 없으면 이전 단계로 돌아가 다른 선택
<br/><br/>

- 알고리즘 성능 분석
  - 시간 복잡도
    - 알고리즘 수행 시간 분석
    - 빅오(Big-O) 표기법 유형
      - O(1) : 스택, Hash 함수
      - O(log n) : 이진탐색
      - O(n) : 배열
      - O(n log n) : 퀵정렬, 힙정렬, 병합정렬
      - O(n<sup>2</sup>) : 버블정렬, 삽입정렬, 선택정렬
      - O(2<sup>n</sup>)
      - O(n!)
  - 공간 복잡도
    - 메모리 공간 양
<br/><br/>

- 정렬 알고리즘
  - 퀵 정렬
    - 피벗(기준값)을 사용하여 분할하면서 정렬
    - 시간 복잡도 : 일반적으로 O(n log n), 최악의 경우 O(n<sup>2</sup>)
  - 힙 정렬
    - 추가 메모리를 사용하지 않음
    - 시간 복잡도 : O(n log n)
  - 병합 정렬
    - 반으로 분할하여 정렬한 후 병합
    - 시간 복잡도 : O(n log n)
  - 버블 정렬
    - 인접한 값끼리 비교
    - 시간 복잡도 : O(n<sup>2</sup>)
  - 선택 정렬
    - 최솟값을 찾아 비교 대상과 교체
    - 시간 복잡도 : O(n<sup>2</sup>)
  - 삽입 정렬
    - 현재 값이 삽입될 자리를 찾아 삽입
    - 시간 복잡도 : O(n<sup>2</sup>)
  - 쉘 정렬
    - 삽입 정렬의 단점 개선
  - 기수 정렬
    - 키 값에 따라 분배
<br/><br/>

- 검색 기법
  - 선형 검색
    - 순차적으로 검색
    - 시간 복잡도 : O(N)
  - 이진 검색
    - 검색 범위를 좌측 또는 우측, 반으로 줄여가며 검색
    - 시간 복잡도 : O(log n)
  - 보간 검색
    - 예측 검색
  - 해시 검색
    - 해시 테이블 사용
    - 시간 복잡도 : O(1), 최악의 경우 O(N)
  - 이진 트리 검색
    - 이진 트리 구조
    - 시간 복잡도 : O(log n), 최악의 경우 O(N)
  - 블록 검색
    - 블록으로 나눈 후 블록의 최대값 추출하여 값의 위치 블록 파악한 뒤 해당 블록 내에서 선형 검색
<br/><br/>
